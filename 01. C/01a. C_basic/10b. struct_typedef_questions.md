# <p align="center">**Structure - Questions**</p>

### Question 1:

- Which of the following correctly accesses the x member of the p1 struct?

```C
struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1 = {10, 20};
    // Accessing members of the struct
    // ...
}
```

- Options
	1. p1.x
	2. p1->x
	3. x.p1
	4. x->p1


### Question 2:
- What is the correct way to declare a variable of the Student struct named s1?

```C
struct Student {
    char name[50];
    int roll_no;
    float marks;
};
```

- Options
	1. struct Student s1;
	2. Student s1;
	3. struct s1;
	4. s1 Student;


### Question 3:
- What is wrong with the following program?

```C
struct Data {
	int x;
	int y;	
};

int main() {
	Data data;
	// do something
	return 0
}
```


### Question 4:
- What is wrong with the following program?

```C
struct Data {
	int x = 0;
	int y = 0;	
};

int main() {
	struct Data data;
	// do something
	return 0
}
```


### Question 5:
- Explain output of the following program

```C
#include <stdio.h>

struct Data {
	int x;
	int y;	
};

int main() {
	struct Data data = {1, 2};
    printf("x: %d, y: %d", data.x, data.y);
	return 0;
}
```

- Output:
```
x: 1, y: 2
```


### Question 6:
- Explain output of the following program

```C
#include <stdio.h>

struct Data {
	int x;
	int y;	
};

int main() {
	struct Data data = {10};
    printf("x: %d, y: %d", data.x, data.y);
	return 0;
}
```

- Output:
```
x: 10, y: 0
```


### Question 7:

- Explain output of the following program?
```C
#include <stdio.h>
#include <string.h>
 
struct Employee {
    char name[50];
    int age;
    float salary;
};

int main() {
    struct Employee emp;
    strcpy(emp.name, "John Doe");
    emp.age = 30;
    emp.salary = 5000.0;
    printf("%s is %d years old and earns %.2f\n", 
            emp.name, emp.age, emp.salary);
}
```

- Output
```
John Doe is 30 years old and earns 5000.00
```


### Question 8:
- What is the likely output the following code?

```C
#include <stdio.h>

struct Data {
  int value;
  char text[50];
};

int main() {
  struct Data data; 
  printf("data.value: %d\n", data.value); 
  printf("data.text: %s\n", data.text); 
  return 0;
}
```

- Options:
	1. Asnwer 1:
		```
		data.value: 0
		data.text: (empty string)
		```
	2. Asnwer 2:
		- data.value: some garbage value
		- data.text: some garbage characters

	3. Answer 3: The code produces a compilation error.

	4. Answer 4: The code might crash due to accessing uninitialized memory.


### Question 9:

- What is the output of the following C code 

```C
#include <stdio.h>

struct Data {
  int value;
  char text[50];
};

int main() {
  struct Data data = {0}; 
  printf("data.value: %d\n", data.value); 
  printf("data.text: %s\n", data.text); 
  return 0;
}
```
- Options:
	1. Answer 1:
	data.value: 0
	data.text: (empty string)

	2. Answer 2:
	data.value: (garbage value)
	data.text: (garbage characters)

	3. Anwser 3: The code produces a compilation error.

	4. Answer 4: The code might crash due to accessing uninitialized memory.



### Question 10:

- Which of the following is the correct way to assign the value 5 to the width member of the rect struct?
	1. width = 5;
	2. rect.width = 5;
	3. Rectangle.width = 5;
	4. rect->width = 5;

```C
struct Rectangle {
	int width;
	int height;
};

int main() {
	struct Rectangle rect;
	// ...
}
```


### Question 11:

- How do you pass the c1 struct to the "calculateArea" function?
	1. calculateArea(c1.radius);
	2. calculateArea(&c1);
	3. calculateArea(c1);
	4. calculateArea(Circle);

```C
struct Circle {
	float radius;
};

float calculateArea(struct Circle c) {
	// ...
}

int main () {
    struct Circle c1;
    // call calculateArea
    return 0;
}
```


### Question 12:

- How do you access the age member of the p1 struct using the ptr pointer?
	1. ptr.age
	2. ptr->age
	3. age.ptr
	4. age->ptr

```C
struct Person {
	char name[50];
	int age;
};

int main() {
	struct Person *ptr;
	struct Person p1 = {"Jane Doe", 25};
	ptr = &p1;
	// ...

	return 0;
}
```


### Question 13:

- What is the purpose of the "typedef" keyword in this code?
	1. To define a new data type called "Point".
	2. To create an alias "Point" for the struct definition.
	3. To declare a variable of the struct named "Point".
	4. To dynamically allocate memory for the struct.

```C
typedef struct {
	int x;
	int y;
} Point;

int main() {
	Point p1 = {10, 20};
  // ...
}
```


### Question 14:

- Which of the following correctly assigns the value "Laptop" to the name member of the prod struct using the ptr pointer?
	1. ptr.name = "Laptop";
	2. *ptr.name = "Laptop";
	3. strcpy(ptr->name, "Laptop");
	4. strcpy(ptr.name, "Laptop");

```C
struct Product {
	char name[50];
	float price;
};

int main() {
	struct Product prod;
	struct Product *ptr;
	ptr = &prod; 
	// ...
}
```


### Question 15:
- What is output of the following program?

```C
#include <stdio.h>

struct Book {
	char title[50];
	char author[50];
};

void print_book(struct Book book) {
	printf("Title: %s\n", book.title);
}

int main() {
	struct Book my_book = {
		"The Lord of the Rings", 
		"J.R.R. Tolkien"
	};
	printf("Title: %s\n", my_book.title);
	return 0;
}
```


### Question 16:
- Why is it not necessary to use a pointer to struct Book (i.e., struct Book *) in the print_book function?

```C
#include <stdio.h>

struct Book {
	char title[50];
	char author[50];
};

void print_book(struct Book book) {
	printf("Title: %s\n", book.title);
}

int main() {
	struct Book my_book = {
		"The Lord of the Rings", 
		"J.R.R. Tolkien"
	};
	printf("Title: %s\n", my_book.title);
	return 0;
}
```

- Options:
	1. Because the print_book function only needs to read the data of the Book struct, not modify it.

	2. Because passing a pointer to a struct is always less efficient than passing the struct directly.

	3. Because using pointers with structs is generally considered bad practice in C.

	4. Because the Book struct is too small to justify the overhead of using a pointer.


### Question 17:
- What is wrong with the following program?
	1. The move_point function should return a struct Point.
	2. The move_point function should take a struct Point * as an argument.
	3. The p1 variable should be passed to move_point using &p1.
	4. Both (2) and (3).
```C
#include <stdio.h>

struct Point {
	int x;
	int y;
};

void move_point(struct Point p, int dx, int dy) {
  p.x += dx;
  p.y += dy;
}

int main() {
	struct Point p1 = {1, 2};
	move_point(p1, 3, 4);
	printf("p1.x: %d, p1.y: %d\n", p1.x, p1.y);
	return 0;
}
```


### Question 18:
- Which of the following is the most suitable choice for the given program?
	1. The print_person function should take a Person * as an argument.
	2. The my_person variable should be passed to print_person without the & operator.
	3. The strcpy function should not be used to assign the name.
	4. There is nothing wrong with the program.

```C
#include <stdio.h>

typedef struct {
	char name[50];
	int age;
} Person;

void print_person(Person p) {
	printf("Name: %s, Age: %d\n", p.name, p.age);
}

int main() {
	Person my_person;
	strcpy(my_person.name, "John Doe");
	my_person.age = 30;
	print_person(&my_person); 
	return 0;
}
```


### Question 19:
- What is the output of the following code?

```C
#include <stdio.h>
#include <stdlib.h>

struct Point {
	int x;
	int y;
};

int main() {
	struct Point *p = malloc(sizeof(struct Point));
	if (p == NULL) {
		printf("Memory allocation failed!\n");
		return 1;
	}
	p->x = 10;
	p->y = 20;
	printf("x: %d, y: %d\n", p->x, p->y);
	free(p);
	return 0;
}
```


### Question 20:
- What is wrong with the following code?
	1. The rect pointer is not initialized before being used.
	2. The free(rect) statement is not necessary.
	3. The -> operator should be replaced with the . operator.
	4. There is nothing wrong with the code.
	
```C
#include <stdio.h>
#include <stdlib.h>

struct Rectangle {
	int width;
	int height;
};

int main() {
	struct Rectangle *rect;
	rect->width = 5;
	rect->height = 10; Â  

	printf("Area: %d\n", rect->width * rect->height);
	free(rect);
	return 0;
}
```
